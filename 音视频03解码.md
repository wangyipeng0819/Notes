---
title: 音视频解码
date: 2025-09-15 11:55:16
tags:
- 编解码
categories:
- 音视频开发
cover: https://bu.dusays.com/2025/09/15/68c78f0020a85.png
---

## 音频解码

### 准备工作

准备一个mp4文件提取其中的视频数据转为aac

```
ffmpeg -i input.mp4 -vn -ac 2 -ar 44100 -f f32le output.aac
```

使用ffplay来播放pcm数据

FFmpeg中有两种表示PCM数据包的模式，分别是planer和packed模式。

其中packed又叫做交错模式，planer叫平面模式，

```
用packed模式表示是这样子的：
// 我们用L表示左声道数据，用R表示右声道数据
LRLRLRLRLRLRLRLR
而用laner模式表示的话，则是这样子的：
// 我们用L表示左声道数据，用R表示右声道数据
LLLLLLLL RRRRRRRR
```

```
在FFmpeg中，packed模式的格式有：
AV_SAMPLE_FMT_U8,          ///< unsigned 8 bits
AV_SAMPLE_FMT_S16,         ///< signed 16 bits
AV_SAMPLE_FMT_S32,         ///< signed 32 bits
AV_SAMPLE_FMT_FLT,         ///< float
AV_SAMPLE_FMT_DBL,         ///< double
它的数据只存在于AVFrame的data[0]中。
```

```
而planer模式一般是FFmpeg内部储存音频所使用的模式，例如通过一般planar模式的后面都有字母P标识，planar模式的格式有：
AV_SAMPLE_FMT_U8P,         ///< unsigned 8 bits, planar
AV_SAMPLE_FMT_S16P,        ///< signed 16 bits, planar
AV_SAMPLE_FMT_S32P,        ///< signed 32 bits, planar
AV_SAMPLE_FMT_FLTP,        ///< float, planar
AV_SAMPLE_FMT_DBLP,        ///< double, planar
AV_SAMPLE_FMT_S64,         ///< signed 64 bits
AV_SAMPLE_FMT_S64P,        ///< signed 64 bits, planar
```

### 解码流程

![](https://bu.dusays.com/2025/09/15/68c80f3008de6.png)

### 代码部分分析

```c++
#include <QDebug>
extern "C"
{
#include "libavcodec/avcodec.h"
#include "libavformat/avformat.h"
}

int main()
{
    const char inFileName[] = "output.aac";
    const char outFileName[] = "test.pcm";
    FILE *file=fopen(outFileName,"wb+");
    if(!file){
        qDebug() << "Cannot open output file";
        return -1;
    }

    // 负责解析输入文件的容器格式
    AVFormatContext *fmtCtx = avformat_alloc_context();
    AVCodecContext *codecCtx = NULL; // 音频解码器的上下文，保存采样率、声道数等。
    AVPacket *pkt = av_packet_alloc();
    AVFrame *frame = av_frame_alloc();

    int aStreamIndex = -1;  //  存储音频流在输入文件中的索引位置。

    do{
        //  打开输入音频文件（AAC），并填充 fmtCtx
        if(avformat_open_input(&fmtCtx,inFileName,NULL,NULL)<0){
            qDebug() << "Cannot open input file";
            return -1;
        }
        //  探测文件中所有流的信息，更新 fmtCtx->streams
        if(avformat_find_stream_info(fmtCtx,NULL)<0){
            qDebug() << "Cannot find any stream in file";
            return -1;
        }

        //  遍历所有流，找到音频流索引并保存。
        for(size_t i=0;i<fmtCtx->nb_streams;i++){
            if(fmtCtx->streams[i]->codecpar->codec_type==AVMEDIA_TYPE_AUDIO){
                aStreamIndex=(int)i;
                break;
            }
        }
        if(aStreamIndex==-1){
            qDebug() << "Cannot find audio stream";
            return -1;
        }

        //  提取解码参数和初始化解码器
        AVCodecParameters *aCodecPara = fmtCtx->streams[aStreamIndex]->codecpar;
        // 通过 codec_id 查找对应的解码器
        const AVCodec *codec = avcodec_find_decoder(aCodecPara->codec_id);
        if(!codec){
            qDebug() << "Cannot find any codec for audio";
            return -1;
        }
        codecCtx = avcodec_alloc_context3(codec);
        //  avcodec_parameters_to_context 将 codecpar 参数复制到 codecCtx。
        if(avcodec_parameters_to_context(codecCtx,aCodecPara)<0){
            qDebug() << "Cannot alloc codec context";
            return -1;
        }
        //  设置时间基
        codecCtx->pkt_timebase = fmtCtx->streams[aStreamIndex]->time_base;
        
        
        if(avcodec_open2(codecCtx,codec,NULL)<0){
            qDebug() << "Cannot open audio codec";
            return -1;
        }
        // 循环读取压缩包 pkt，直到文件结束。
        while(av_read_frame(fmtCtx,pkt)>=0){
            // 过滤音频流并送入解码器
            if(pkt->stream_index==aStreamIndex){
                //  判断包是否属于音频流，送入解码器处理。
                if(avcodec_send_packet(codecCtx,pkt)>=0){
                    // 解码器内部缓存机制可能返回多个 frame，逐个取出。
                    while(avcodec_receive_frame(codecCtx,frame)>=0){
                        //  处理 Planar 音频数据
                        if(av_sample_fmt_is_planar(codecCtx->sample_fmt)){
                            // 每个采样的字节数，S16 为 2
                            int numBytes =av_get_bytes_per_sample(codecCtx->sample_fmt);
                            //pcm播放时是LRLRLR格式，所以要交错保存数据
                            for(int i=0;i<frame->nb_samples;i++){
                                for(int ch=0;ch<codecCtx->channels;ch++){
                                    fwrite((char*)frame->data[ch]+numBytes*i,1,numBytes,file);
                                }
                            }
                        }
                    }
                }
            }
            av_packet_unref(pkt);  // 释放当前 pkt 中的引用，避免内存泄漏。
        }
    }while(0);
    av_frame_free(&frame);
    av_packet_free(&pkt);
    avcodec_close(codecCtx);
    avcodec_free_context(&codecCtx);
    avformat_free_context(fmtCtx);
    fclose(file);
    return 0;
}
```

**do{...}while(0) 的作用是：**

- **构造一个可以用 `break` 跳出的代码块**
- **让中途退出逻辑更清晰**
- **通常搭配资源统一释放使用**





## 视频编码

### 准备工作

准备一个mp4文件提取其中的视频数据转为h264，可以使用ffmpeg提供的命令

```
ffmpeg -i input.mp4 -c:v copy -an output.h264
```

接着我们可以使用ffplay来验证yuv文件

```
ffplay -f rawvideo -pixel_format yuv420p -video_size 1280x720 output.yuv
```

### 解码流程

![](https://bu.dusays.com/2025/09/15/68c7e0a35d58d.png)

```c++
#include <QDebug>
extern "C" {
#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
}

int main(int argc, char *argv[]) {
    const char *inputFileName = "D:\\code\\ffmpeg\\output.h264";
    const char *outputFileName = "out.yuv";

    // 打开输入文件
    AVFormatContext *formatCtx = avformat_alloc_context(); // 分配上下文
    // 用avformat_open_input打开输入文件
    if (avformat_open_input(&formatCtx, inputFileName, NULL, NULL) != 0) {
        qDebug() << "Error: could not open input file";
        return -1;
    }

    // 获取流信息
    if (avformat_find_stream_info(formatCtx, NULL) < 0) {
        qDebug() << "Error: could not find stream information";
        avformat_close_input(&formatCtx); // 打开失败就关闭输入的文件
        return -1;
    }

    // 查找视频流
    int videoStream = -1;
    // 遍历所有流，找到第一个video类型的流
    for (int i = 0; i < formatCtx->nb_streams; i++) {
        if (formatCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
            videoStream = i; // 找到之后保存索引  
            break;
        }
    }

    if (videoStream == -1) {
        qDebug() << "Error: could not find video stream";
        avformat_close_input(&formatCtx);  //失败了 还是关闭 打开的 输入文件
        return -1;
    }

    // 获取视频解码器，根据code_id查找对应的解码器
    AVCodecParameters *codecParams = formatCtx->streams[videoStream]->codecpar;
    const AVCodec *codec = avcodec_find_decoder(codecParams->codec_id);
    if (!codec) {
        qDebug() << "Error: unsupported codec";
        avformat_close_input(&formatCtx); // 失败了关闭打开的输入文件
        return -1;
    }

    // 初始化解码上下文
    AVCodecContext *codecCtx = avcodec_alloc_context3(codec);
    avcodec_parameters_to_context(codecCtx, codecParams);  // 将参数拷贝过去
    if (avcodec_open2(codecCtx, codec, NULL) < 0) {  // 打开解码器
        qDebug() << "Error: could not open codec";
        avformat_close_input(&formatCtx);
        return -1;
    }

    // 打开输出文件
    FILE *outputFile = fopen(outputFileName, "wb");
    if (!outputFile) { // 打开失败
        qDebug() << "Error: could not open output file";
        avcodec_close(codecCtx);  // 关闭解码器
        avformat_close_input(&formatCtx);  // 关闭输入文件
        return -1;
    }

    // 解码并输出 YUV420 文件
    AVFrame *frame = av_frame_alloc();
    AVPacket packet;
    av_init_packet(&packet);  // 初始化AVPacket，存放压缩数据包
    int ret = 0;

    // 循环读取数据并解码  av_read_frame 从文件中读取一个数据包
    while (av_read_frame(formatCtx, &packet) >= 0) {
        if (packet.stream_index == videoStream) { // 如果属于视频流，送入解码器。
            ret = avcodec_send_packet(codecCtx, &packet);
            if (ret < 0) {
                qDebug() << "Error: sending packet to decoder";
                break;
            }
            
            // 从解码器取出帧
            while (ret >= 0) {
                ret = avcodec_receive_frame(codecCtx, frame); // 获取解码器中的帧
                if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
                    break;
                else if (ret < 0) {
                    qDebug() << "Error: receiving frame from decoder";
                    break;
                }

                // 将解码后的 YUV420 数据写入文件
                for (int i = 0; i < frame->height; i++) {
                    fwrite(frame->data[0] + i * frame->linesize[0], 1, frame->width, outputFile);
                }
                for (int i = 0; i < frame->height / 2; i++) {
                    fwrite(frame->data[1] + i * frame->linesize[1], 1, frame->width / 2, outputFile);
                }
                for (int i = 0; i < frame->height / 2; i++) {
                    fwrite(frame->data[2] + i * frame->linesize[2], 1, frame->width / 2, outputFile);
                }
            }
        }
        av_packet_unref(&packet);
    }

    // 释放资源
    fclose(outputFile);
    av_frame_free(&frame);
    avcodec_close(codecCtx);
    avformat_close_input(&formatCtx);

    qDebug() << "Finished decoding and writing YUV420 file";
}

```

```
H.264 文件 (.h264)
        ↓
avformat_open_input → 解析封装
        ↓
找到视频流 & codec
        ↓
avcodec_open2 → 初始化解码器
        ↓
av_read_frame 读取压缩包
        ↓
avcodec_send_packet 送入解码器
        ↓
avcodec_receive_frame 得到 YUV420 帧
        ↓
写入 out.yuv 文件
```





## 一些疑问

### 1.YUV和H.264编解码的转换



