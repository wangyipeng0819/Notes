---
title: æ’åºç®—æ³•
date: 2025-05-19 15:54:40
tags:
- æ—¥å¸¸åˆ·é¢˜
categories:
- codetop
cover: https://bu.dusays.com/2025/05/19/682ae4b046ba4.png
---

### åŠ›æ‰£912. æ’åºæ•°ç»„

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œè¯·ä½ å°†è¯¥æ•°ç»„å‡åºæ’åˆ—ã€‚

ä½ å¿…é¡»åœ¨ **ä¸ä½¿ç”¨ä»»ä½•å†…ç½®å‡½æ•°** çš„æƒ…å†µä¸‹è§£å†³é—®é¢˜ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º `O(nlog(n))`ï¼Œå¹¶ä¸”ç©ºé—´å¤æ‚åº¦å°½å¯èƒ½å°ã€‚

#### å¿«é€Ÿæ’åºå’Œå½’å¹¶æ’åº

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        // qsort(nums, 0, nums.size()- 1);
        // merge_sort(nums, 0, nums.size()- 1);
        return nums;
    }

    void qsort(vector<int>& q, int l, int r)
    {
        if (l >= r) return ;

        int x = q[(l + r) >> 1], i = l - 1, j = r + 1;
        while(i < j)
        {
            do i ++ ; while(q[i] < x);
            do j -- ; while (q[j] > x);
            if (i < j)
            {
                int t = q[i];
                q[i] = q[j];
                q[j] = t;
            }
        }
        qsort(q, l, j);
        qsort(q, j + 1, r);
    }

    void merge_sort(vector<int>& q, int l, int r)
    {
        if (l >= r) return;

        int mid = (l + r) / 2;

        merge_sort(q, l, mid), merge_sort(q, mid + 1, r);

        vector<int> tmp(r - l + 1);
        int k = 0, i = l, j = mid + 1;
        while (i <= mid && j <= r)
            if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
            else tmp[k ++ ] = q[j ++ ];
        while(i <= mid) tmp[k ++ ] = q[i ++ ];
        while (j <= r) tmp[k ++ ] = q[j ++ ];
       // æ¯æ¬¡é€’å½’ï¼Œtmpéƒ½æ˜¯ä»0å¼€å§‹çš„
        for (int i = l, j = 0; i <= r; i ++ , j ++ ) q[i] = tmp[j];
    }
};
```

#### å †æ’åº(å¤§æ ¹å †å’Œå°æ ¹å †)

```c++
void heap(vector<int>& nums)
{
    // ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨ 1-based ç´¢å¼•ï¼Œåœ¨å‰é¢æ’å…¥ä¸€ä¸ªæ— ç”¨çš„æ•°
    nums.insert(nums.begin(), -1);
    int n = nums.size() - 1;

    // å»ºå †ï¼ˆå°æ ¹å †ï¼‰
    for (int i = n / 2; i; i--) down(nums, i, n);
    for (int i = n; i > 1; i--)
    {
        swap(nums[1], nums[i]);
        down(nums, 1, i - 1);
    }
    // å»æ‰å“¨å…µå…ƒç´ ï¼ˆè¿˜åŸä¸º 0-based æ•°ç»„ï¼‰
    nums.erase(nums.begin());
    reverse(nums.begin(), nums.end());
}


void down(vector<int>& nums, int u, int size)
{
    int t = u;
    if (u * 2 <= size && nums[u * 2] < nums[t]) 
        t = u * 2;
    if (u * 2 + 1 <= size  && nums[u * 2 + 1] < nums[t]) 
        t = u * 2 + 1;
    if (u != t)
    {
        swap(nums[t], nums[u]);
        down(nums,t,size);
    }
}
```

ğŸ§ éœ€è¦æ³¨æ„ä¸€ç‚¹å°±æ˜¯ï¼Œç®—æ³•æ¨¡æ¿æ˜¯ä»å°åˆ°å¤§è¾“å‡ºæœ€å°çš„æ•°ï¼Œä½†æ•´ä¸ªçš„å †å¹¶ä¸æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥éœ€è¦åŠ ä¸Šä¸‹é¢çš„è¿™æ®µä»£ç 

```c++
for (int i = n; i > 1; i--)
{
    swap(nums[1], nums[i]);
    down(nums, 1, i - 1);
}
```

âœ…æœ€å¥½çš„æ–¹æ³•è¿˜æ˜¯ä½¿ç”¨å¤§æ ¹å †æ¥å®ç°å‡åºæ’åº

```c++
void heap(vector<int>& nums)
{
    nums.insert(nums.begin(), -1);   // ä¸‹æ ‡ä»1å¼€å§‹
    int n = nums.size() - 1;
    
    // å»ºç«‹å¤§æ ¹å †
    for (int i = n / 2; i; i -- ) down(nums, i, n);
    
    for (int i = n; i > 1; i -- )
    {
        swap(nums[1], nums[i]);
        up(nums, 1, i - 1);
	}
    num.erase(nums.begin());
}

void down(vector<int>& nums, int u, int size)
{
    int t = u;
    if (u * 2 <= size && nums[u * 2] > nums[t]) t = u * 2;    
    if (u * 2 + 1 <= size && nums[u * 2 + 1] > nums[t]) t = u * 2 + 1;
    
    if (u != t)
    {
        swap(nums[u], nums[t]);
        down(nums, t, size);
    }
}
```

è¿™é‡Œå¿’ä¸€äº›å®¹å™¨çš„çŸ¥è¯†

```c++
std::vector<æ•°æ®ç±»å‹> å˜é‡å;
std::vector<int> s;
std::vector<int> s{1,2,3};
std::vector<int> s(5);  // è®¾ç½®äº†5ä¸ªå¤§å°çš„å®¹å™¨
std::vector<int> s(5,100);  // è¿™ä¸ªå®¹å™¨æ‹¥æœ‰äº”ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ çš„åˆå§‹å€¼ä¸º100
```

å®¹å™¨çš„å‡ ä¸ªæ–°ç”¨æ³•ï¼š

```c++
std::vector<int> s;
s.push_back(å€¼);  //å°†å€¼æ·»åŠ åˆ°å®¹å™¨æœ«å°¾
s.pop_back();  //å°†æœ«å°¾çš„å€¼åˆ é™¤æ‰
s.insert(s.begin()+2, 2); // åœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ 
s.assign(10,100); //å°†sé‡æ–°åˆå§‹åŒ–ä¸ºæ‹¥æœ‰10ä¸ªå…ƒç´   æ¯ä¸ªå…ƒç´ ä½100çš„å®¹å™¨
s.erase(s.begin() + 2);   // åˆ é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ 
s.clear(); // å°†å®¹å™¨æ¸…ç©º
s.empty(); //çœ‹çœ‹æ˜¯ä¸æ˜¯ç©ºçš„
```

å®¹å™¨æ¯”æ•°ç»„æ›´çµæ´»ï¼Œæ’åºçš„æ—¶å€™å¯ä»¥å½“åšæ•°ç»„æ¥æ“ä½œï¼ï¼ï¼

### åŠ›æ‰£56. åˆå¹¶åŒºé—´

**ACMæ¨¡å¼**

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef pair<int,int> PII;

void merge(vector<PII> &segs)
{
    vector<PII> res;
    
    sort(segs.begin(), segs.end());
    
    int st = -2e9, ed = -2e9;
    for(auto seg : segs)
        if(ed < seg.first)
        {
            if (st!=-2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);
    
    if(st != -2e9) res.push_back({st, ed});
    
    segs = res;
}

int main()
{
    int n;
    scanf("%d", &n);
    
    vector<PII> segs;
    for(int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        segs.push_back({l, r});
    }
    
    merge(segs);
    
    cout << segs.size() << endl;
    
    return 0;
}
```

**æ ¸å¿ƒä»£ç æ¨¡å¼**

```c++
// æ­¤é¢˜å…¨ä¸ºéè´Ÿæ•°ï¼Œæ‰€ä»¥st  ed   è®¾ç½®ä¸º-1å³å¯
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        sort(res.begin(),res.end());

        int st = -1, ed = -1;

        for(int i = 0; i < intervals.size(); i ++ )
            if(ed < intervals[i][0])
            {
                if(st != -1) res.push_back({st, ed});
                st = intervals[i][0], ed = intervals[i][1];
            }
            else ed = max(ed, intervals[i][1]);

        if(st != -1) res.push_back({st, ed});

        return res;
    }
};
```

### åŠ›æ‰£148. æ’åºé“¾è¡¨

æ–¹æ¡ˆä¸€ï¼šå¼€ä¸€ä¸ªæ•°ç»„ï¼ŒæŠŠé“¾è¡¨çš„å€¼å¤åˆ¶åˆ°æ•°ç»„é‡Œé¢è¿›è¡Œæ’åºï¼Œæ’åºå®Œæˆåå†æŠŠå€¼å¤åˆ¶åˆ°é“¾è¡¨é‡Œé¢

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head) return head;
        vector<int> a;
        auto p = head;
        while(p != NULL){
            a.push_back(p->val);
            p = p->next;
        }
        delete p;
        // sort(a.begin(), a.end());
        qsort(a, 0, a.size() - 1);
        auto q = head;
        for(const auto &c : a){
            q->val = c;
            q = q->next;
        }
        delete q;
        
        return head;
    }
    void qsort(vector<int> &a, int l, int r)
    {
        if (l >= r) return ;

        int i = l - 1, j = r + 1, x = a[l + r >> 1];

        while (i < j)
        {
            do i ++ ; while (a[i] < x);
            do j -- ; while (a[j] > x);
            if (i < j)
            {
                int t = a[i];
                a[i] = a[j];
                a[j] = t;
            }
        }
        qsort(a, l, j);
        qsort(a, j + 1, r);
    }
};
// ä½¿ç”¨è‡ªå·±å†™çš„å¿«æ’ï¼Œæ•ˆç‡æå‡äº† 10% ä»¥ä¸Š
```

### åŠ›æ‰£179. æœ€å¤§æ•°ï¼ˆä»…ä»…æ’åºè§£å†³ä¸äº†ï¼‰

ç°åœ¨èƒ½æƒ³åˆ°çš„å°±æ˜¯ å¦‚æœæœ€é«˜ä½ä¸åŒï¼Œé‚£ä¹ˆæ ¹æ®æœ€é«˜ä½è¿›è¡Œæ’åºï¼Œå¦‚æœæœ€é«˜ä½ç›¸åŒåˆ™æ¯”è¾ƒä¸‹ä¸€ä½ï¼Œä¾æ¬¡ç±»æ¨

