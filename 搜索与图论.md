---
title: 搜索与图论
date: 2025-06-06 11:11:48
tags:
- 算法
categories:
- 数据结构
cover: https://bu.dusays.com/2025/03/19/67da2000a9226.png
---

## DFS一些经典题目

### acwing 842. 排列数字

给定一个整数 n，将数字 1∼n 排成一排，全排列数字

```c++
#include <iostream>

using namespace std;

const int N = 10;

int n, path[N];
bool st[N];

void dfs(int u)
{
    if (u == n)
    {
        // 输出保存的结果
        for (int i = 0; i < n; i ++ ) printf("%d ", path[i]);
        puts("");
    }
    
    for (int i = 1; i <= n; i ++ )
    	if (!st[i]) // 没有用过的数
        {
            path[u] = i;
            st[i] = true;  // i被用过
            dfs(u + 1);  // 走到下一层
            st[i] = false;  //恢复现场
        }
}

int main()
{
    cin >> n;
    dfs(0);
    return 0;
}
```

### acwing 843. n-皇后问题

```c++
// 解法 一
#include <iostream>

using namespace std;

const int N = 10;

int n;
bool row[N], col[N], dg[N * 2], udg[N * 2];
char g[N][N];

void dfs(int x, int y, int s)
{
    if (s > n) return ;
    if (y == n) y = 0 , x ++ ;
    
    if (x == n)
    {
        if (s == n)
        {
            for (int i = 0; i < n; i ++ ) puts(g[i]);
            puts("");
        }
        return ;
    }
    
    g[x][y] = '.';
    dfs(x, y + 1, s);
    
    if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n])
    {
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        g[x][y] = 'Q';
        dfs(x, y + 1, s + 1);
        g[x][y] = '.';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
    }
}

int main()
{
    cin >> n;
    
    dfs(0, 0, 0);
    
    return 0;
}
```



```c++
// 解法 二
#include <iostream>
using namespace std;

int n;
const int N = 20;
bool col[N], dg[N], udg[N];
char g[N][N];

void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);
        puts("");
    }
    
    for (int i = 0; i < n; i ++ )
        if (!col[i] && !dg[u + i] && !udg[u - i + n])
        {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[u - i + n] = true;
            dfs(u + 1);
            col[i] = dg[u + i] = udg[u - i + n] = false;
            g[u][i] = '.';
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';
    
    dfs(0);
    
    return 0;
}
```

解法二的思想就是在每一行放皇后，这是控制了行

## BFS一些题目

​	所谓**广度优先**。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。

这样做的结果是，BFS 算法找到的路径是从起点开始的 **最短** 合法路径。换言之，这条路径所包含的边数最小。	

​	**算法过程**可以看做是图上火苗传播的过程：最开始只有起点着火了，在每一时刻，有火的节点都向它相邻的所有节点传播火苗。

**实现**

```
bfs(s)
{
	q = new queue();
	q.push(s), visited[s] = true;
	while (!q.empty())
	{
		u = q.pop();
		for each edge(u,v){
			if (!visited[v])
			{
				q.push(v)
				vistied[v] = true;
			}
		}
	}
}
```



### AcWing 844 走迷宫

最初，有一个人位于左上角 (1,1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。

数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> PII;

const int N = 110;
int n, m, g[N][N], d[N][N];

int bfs()
{
    queue<PII> q;
    
    memset(d, -1, sizeof d);
    d[0][0] = 0;
    q.push({0, 0});
    
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    
    while (q.size())
    {
        auto t = q.front();
        q.pop();
        
        for (int i = 0; i < 4; i ++ )
        {
            int x = t.first + dx[i], y = t.second + dy[i];
            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1;
                q.push({x, y});
            }
        }
    }
    
    return d[n - 1][m - 1];
}


int main()
{
    scanf("%d%d", &n, &m);
    
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            scanf("%d", &g[i][j]);
    cout << bfs() << endl;
    
    return 0;
}
```



### AcWing 845 八数码

```
1 2 3
x 4 6
7 5 8
// 最后要得到 12345678x  这个字符串
```

```c++
#include <bits/stdc++.h>
using namespace std;

int bfs(string state)
{
    queue<string> q;
    unordered_map<string, int> d;
    
    q.push(state);
    d[state] = 0;
    
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    
    string end = "12345678x";
    while(q.size())
    {
        auto t = q.front();
        q.pop();
        
        if (t == end) return d[t];
        
        int distance = d[t];
        int k = t.find('x');
        int x = k / 3, y = k % 3;
        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {
                swap(t[a * 3 + b], t[k]);
                if (!d.count(t))
                {
                    q.push(t);
                    d[t] = distance + 1;
                }
                swap(t[a * 3 + b], t[k]);
            }
        }
    }
    return -1;
}

int main()
{
    char s[2];
    string state;
    
    for (int i = 0; i < 9; i ++ )
    {
        cin >> s;
        state += *s;
    }
    
    cout << bfs(state) << endl;
    
    return 0;
}
```



## 树与图的深度优先遍历 

### acwing 845.树的重心

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010, M = N * 2;
int h[N], e[M], ne[M], idx;
int n, ans = N;
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int dfs(int u)
{
    st[u] = true;
    
    int size = 0, sum = 0;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (st[j]) continue;
        
        int s= dfs(j);
        size = max(size, s);
        sum += s;
    }
    size = max(size, n - sum - 1);
    ans = min(ans, size);
    
    return sum + 1;
}

int main()
{
    scanf("%d", &n);
    
    memset(h, -1, sizeof h);
    
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b,a );
    }
    
    dfs(1);
    
    cout << ans << endl;
    
    return 0;
}
```

做一个说明，`h[i]`表示i的头节点索引；`e[idx]`是当前边指向的节点，`ne[idx]`是下一个邻接边的索引；idx是边的编号

```c++
// 这部分需要理解一下
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
h[a]    头指针，记录以节点a为起点的第一条边的编号，如果为-1，表示a没有任何边
e[idx]  记录第idx条边的终点节点编号
ne[idx] 同一起点的下一条边的编号。如果为-1，表示这是最后一条边
假设 add(1,2)
e[0] = 2, ne[0] = -1, h[1] = 0
h[1] --> idx:0 --> b:2, ne:-1     // 就是这种样子的

add(1,3) 
e[1] = 3, ne[1] = h[1], h[1] = 1
h[1] --> idx:1 --> 3 ---- idx:0 ---- > 2, ne:-1     // 就是这种样子的
// 边的插入就是头插法
```



## 树与图的广度优先遍历

### AcWing 847.图中点的层次

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;

int n, m;
int e[N], ne[N], h[N], idx ;
int d[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int bfs()
{
    memset(d, -1, sizeof d);
    queue<int> q;
    d[1] = 0;
    q.push(1);
    
    while(q.size())
    {
        int t = q.front();
        q.pop();
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if(d[j] == -1)
            {
                d[j] = d[t] + 1;
                q.push(j);
            }
        }
    }
    
    return d[n];
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    
    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }
    
    cout << bfs() << endl;
    return 0;
}
```

凡是`bfs()`的，都用到一个队列来存储 `while(q.size())`

## 拓扑排序

### AcWing 848. 有向图的拓扑序列

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int in[N];  // 记录入度的
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool topsort()
{
    int hh = 0, tt = -1;
    
    for (int i = 1; i <= n; i ++ )
        if (!in[i]) // 遍历所有节点，入度为0的入队
            q[ ++ tt] = i;
            
    while(hh <= tt)  // 只要队列不为空，就一直查
    {
        int t = q[hh ++ ];
        
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (--in[j] == 0)// 遍历节点所有的子节点，如果减去父节点的入度后为0的话那就入队
                q[ ++ tt] = j;
        }
    }
    return tt == n - 1; // 队列是从0开始统计的
}

int main()
{
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
        
        in[b] ++ ;
    }
    
    if (!topsort()) puts("-1");
    else
    {
        for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
        puts("");
    }
    return 0;
}
```

## Dijkstra算法

### AcWing 849. Dijkstra求最短路

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 510;

int n, m;		// n 表示点数， m 表示边数
int g[N][N];	// 邻接矩阵，g[i][j] 表示 i 到 j 的边权
int dist[N];	// dist[i] 表示起点到 i 的最短距离
bool st[N];		// st[i] 表示节点 i 是否已经确定最短距离 （即是否已加入集合 S）

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    for (int i = 0; i < n - 1; i ++ )		// 起点到自己的距离为0，最多进行 n - 1 次迭代
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ ) // 贪心策略，先选取最短的点
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]); 
        //从所有还没有确定最短距离的点中，选出 dist 值最小的那个点 t（贪心策略）
        
        st[t] = true;  // 标记 t 已经处理了
    }
    
    if (dist[n] == 0x3f3f3f3f) return -1;  // 无法到达终点
    return dist[n];  // 返回从 1 到 n 的最短距离
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(g, 0x3f, sizeof g);   // 初始化邻接矩阵为无穷大，表示没有边
    
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = min(g[a][b], c);   //  处理重边， 保留最小权值
    }
    
    printf("%d\n", dijkstra());
    return 0;
}
```

## Bellman-Ford算法

### AcWing 853. 有边数限制的最短路（负边）

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 510, M = 10010;
struct Edge
{
    int a, b, c;
}edges[M];

int n, m, k;
int dist[N];
int last[N];

void bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);  // 将 dist 数组初始化为正无穷
    dist[1] = 0;   // 起点（1号点）到自己的距离是 0
    
    for (int i = 0; i < k; i ++ )
    {
        // 防止
        memcpy(last, dist, sizeof dist);
        for (int j = 0; j < m; j ++ ){
            auto e = edges[j];
            // 源点到b点的距离=min(源点到b点的最小距离，源点到a的最小距离+a到b的边权值)
            dist[e.b] = min(dist[e.b], last[e.a] + e.c);
        }
    }
}

int main()
{
    scanf("%d%d%d", &a, &b, &c);
    
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edges[i] = {a, b, c};
    }
    
    bellman_ford();
    
    if (dist[n] > 0x3f3f3f3f / 2) puts("impossible");
    else printf("%d\n", dist[n]);
    
    return 0;
}
```

假如在代码中使用`dist[e.b]=min(dist[e.b],dist[e.a] + e.c);`，我们无法保证`dist[e.a]`是否也在本次循环中被更新，如果被更新了，并且`dist[e.b] > dist[e.a] + e.c`，那么会造成当前节点在事实上“即考虑了一条从某个节点指向a的边，也考虑了a->b”，共两条边。而使用`dist[e.b]=min(dist[e.b],last[e.a] + e.c);`，可以保证a在dist更新后不影响对b的判定，因为后者使用last数组，保存着上一次循环中的dist的值。

### AcWing 851. spfa()---belmanford()队列优化版

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    st[1] = true;
    
    while (q.size())
    {
        auto t = q.front();
        q.pop();
        
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    
    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    int t = spfa();
    
    if (t == 0x3f3f3f3f) puts("impossible");
    else printf("%d\n", t);
    
    return 0;
}
```

### AcWing 852. spfa判断负环

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2010, M = 10010;

int n, m;
int h[N], w[M], e[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool spfa()
{
    queue<int> q;
    
    for (int i = 1; i  <= n; i ++ )
    {
        st[i] = true;
        q.push(i);
    }
    
    while (q.size())
    {
        int t = q.front();
        q.pop();
        
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    
    return false;
}

int main()
{
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    if (spfa()) puts("Yes");
    else puts("No");
    
    return 0;
}
```

### 多源最短路径floyd----AcWing 854. Floyd求最短路径

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2010, INF = 1e9;

int n, m, Q;
int d[N][N];

void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main()
{
    scanf("%d%d%d", &n, &m, &Q);
    
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;
            
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        d[a][b] = min(d[a][b], c);
    }
    
    floyd();
    
    while (Q -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        
        int t = d[a][b];
        if (t > INF / 2) puts("impossible");
        else printf("%d\n", t);
    }
    
    return 0;
}
```

## 最小生成树

### Prim算法

从一个顶点出发，不断扩展生成树，始终选择连接已选顶点与未选顶点的最小边。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 510;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

int prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if(!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        
        if (dist[t] == 0x3f3f3f3f) return 0x3f3f3f3f;
        
        res += dist[t];
        
        st[t] = true;
        
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j],g[t][j]);
    }
    return res;
}

int main()
{
    cin >> n >> m;
    memset(g, 0x3f, sizeof g);
    while (m -- )
    {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    
    int t  =prim();
    if (t == 0x3f3f3f3f) puts("impossible");
    else cout << t << endl;
    
    return 0;
}
```

### Kruskal算法

在整个图的所有边中，每次选择权值最小的边，并用并查集判断是否成环。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010, M = 200010, INF = 0x3f3f3f3f;

int n, m; // n个点m条边 
int p[N]; // 并查集

struct Edge
{
    int a, b, w;
    // 重载<,用于sort升序排序
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M]; // 存储边的图

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]); // 查找祖宗结点+路径压缩
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m); // 将所有边按权重大小升序排序
    
    for (int i = 1; i <= n; i ++ ) p[i] = i; // 初始化并查集
    
    int res = 0, cnt = 0;  // 升序枚举每条边
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        
        // 判断a,b是否联通<==>比较a,b的祖宗结点是否相同
        a = find(a), b = find(b);
        if (a != b)
        {
            p[a] = b;
            res += w;  // res记录权重和
            cnt ++ ;   // cnt记录最小生成树中的边数
        }
    }
    // 若cnt中边数不等于n-1,则说明不存在最小生成树
    if (cnt < n - 1) return INF;
    return res;
}


int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w};
    }
    
    int t = kruskal();
    
    if (t == INF) puts("impossible");
    else printf("%d\n", t);
    
    return 0;
}
```

## 二分图

### 染色法判定二分图

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u, int c)
{
    color[u] = c;
    
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!color[j])
        {
            if (!dfs(j, 3 - c)) return false;
        }
        else if (color[j] == c) return false;
    }
    
    return true;
}

int main()
{
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    bool flag = true;
    for (int i = 1; i <= n; i ++ )  // 这个图有可能不连通，所以每个顶点都得遍历
        if (!color[i])
        {
            if (!dfs(i, 1))  // 1 代表一种颜色，从这个颜色开始染色
            {
                flag = false;
                break;
            }
        }
    if (flag) puts("Yes");  // 所有节点都染色成功，可以返回Yes
    else puts("No");
    
    return 0;
}
```

### 二分图最大匹配（匈牙利算法）

这部分用男女关系作为比喻更好理解

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N];
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])  // 遍历x男生的邻接表
    {
        int j = e[i]; 
        if (!st[j])    // 如果这个女生本轮没被访问过
        {
            st[j] = true;
            // 如果 j 没有匹配，或者她现在的男朋友还能找到别人
            if (match[j] == 0 || find(match[j]))  
            {
                match[j] = x;  // 配对成功，j ↔ x
                return true;
            }
        }
    }
    return false;  // 没有找到合适的女生
}

int main()
{
    scanf("%d%d%d", &n1, &n2, &m);
    
    memset(h, -1, sizeof h);
    
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }
    
    int res = 0;  // 计数
    for(int i = 1; i <= n1; i ++ )  // 遍历所有男生节点
    {
        memset(st, false, sizeof st); // 对女生的状态全部清除
        if (find(i)) res ++ ;  // 如果找到了计数加一
    }
    
    printf("%d\n", res);
    
    return 0;
}
```

