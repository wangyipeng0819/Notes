---
title: 贪心算法
date: 2025-08-05 23:15:53
tags:
- 算法
categories:
- 数据结构
cover: https://bu.dusays.com/2025/08/05/689223c5e6721.png
---

## 区间问题

### AcWing 905. 区间选点

给定 N 个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。

输出选择的点的最小数量。

位于区间端点上的点也算作区间内。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 100010;

int n;

struct Range
{
    int l, r;
    bool operator< (const Range &W) const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);
    
    sort(range, range + n);
    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++ )
        if (ed < range[i].l)
        {
            res ++ ;
            ed = range[i].r;
        }
    printf("%d\n", res);
    return 0;
}
```

选端点，只要后面的区间不跟前面的重合就选择，需要注意的是区间排序是按照右端点`r`升序排序的

### AcWing 908. 最大不相交区间数量

代码与区间选点相同，其实思想是一样的！

### AcWing 906. 区间分组

给定 N 个闭区间 [ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

输出最小组数。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W) const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);
    
    sort(range, range + n);
    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i ++ )
    {
        auto r = range[i];
        if (heap.empty() || heap.top() >= r.l) heap.push(r.r);
        // 弹出最早结束的组然后将当前区间加入这个组是为了保证堆内存的每组只有一个区间
        // 然后堆的大小就是组数了
        else
        {
            heap.pop();
            heap.push(r.r);
        }
    }
    printf("%d\n", heap.size());
    
    return 0;
}
```

### AcWing 907. 区间覆盖

给定 N 个区间 [ai,bi] 以及一个区间 [s,t]，请你选择尽量少的区间，将指定区间完全覆盖。

输出最少区间数，如果无法完全覆盖则输出 −1。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W) const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    int st, ed;
    scanf("%d%d", &st, &ed);
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);
    
    sort(range, range + n);
    
    int res = 0;
    bool success = false;
    for(int i = 0; i < n; i ++ )
    {
        int j = i, r = -2e9;
        while (j < n && range[j].l <= st)
        {
            r = max(r, range[j].r);
            j ++ ;
        }
        
        if (r < st)
        {
            res = -1;
            break; // break  是跳过整个for循环
        }
        
        res ++ ;
        if (r >= ed)
        {
            success = true;
            break;
        }
        
        st = r;
        i = j - 1;
    }
    if (!success) res = -1;
    printf("%d\n", res);
    
    return 0;
}
```

## Huffman树

### AcWing 148. 合并果子

在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。

达达决定把所有的果子合成一堆。

每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。

可以看出，所有的果子经过 n−1 次合并之后，就只剩下一堆了。

达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。

假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。

例如有 3 种果子，数目依次为 1，2，9。

可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。

接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。

所以达达总共耗费体力=3+12=15。

可以证明 15 为最小的体力耗费值。

`Huffman树`

```c++
 #include <bits/stdc++.h>
 
 using namespace std;
 
 int main()
 {
     int n;
     scanf("%d", &n);
     
     // priority_queue<int, vector<int>> heap;  这样说大根堆  堆是自动排序
     priority_queue<int, vector<int>, greater<int>> heap;
     while (n -- )
     {
         int x;
         scanf("%d", &x);
         heap.push(x);
     }
     
     int res = 0;
     while (heap.size() > 1)
     {
         int a = heap.top(); heap.pop();
         int b = heap.top(); heap.pop();
         res += a + b;
         heap.push(a + b);
     }
     
     printf("%d\n", res);
     return 0;
 }
```

## 排序不等式

### AcWing 913. 排队打水

有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;
typedef long long LL;
int n;
int t[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &t[i]);
    
    sort(t, t + n);
    reverse(t, t + n);
    
    LL res = 0;
    for (int i = 0; i < n; i ++ ) res += t[i] * i;
    
    printf("%lld\n", res);
    
    return 0;
    
}
```

## 绝对值不等式

### AcWing 104. 货仓选址

在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int n;
int q[N];

int main()
{
    scanf("%d", &n);
    
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    
    sort(q, q + n);
    int res = 0;
    for (int i = 0; i < n; i ++ ) res += abs(q[i] - q[n / 2]);
    
    printf("%d\n", res);
    
    return 0;
}
```



## 推公式

### AcWing 125. 耍杂技的牛

```C++
#include <bits/stdc++.h>

using namespace std;

typedef pair<int, int> PII;

const int N = 50010;

int n;
PII cow[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int s, w;
        scanf("%d%d", &w, &s);
        cow[i] = {w + s, w};
    }
    // 通过排序   把重量和强壮度综合值小的算进去
    // 后续的for循环自然而然就达到了一种贪心策略的效果
    sort(cow, cow + n);
    
    int res = -2e9, sum = 0;
    for (int i = 0; i < n; i ++ )
    {
        int s = cow[i].first - cow[i].second, w = cow[i].second;
        res = max(res, sum - s);
        sum += w;
    }
    
    printf("%d\n", res);
    
    return 0;
}
```

压力最大的牛一定是最底层的牛，我们的算法让w+s最大的放在最下面，可以分成两种情况去看：
1、w很大，s很小：由于w最大的牛在最下面，对其余牛造成的压力自然较小，可能能达到最小的最大压力
2、w很小，s很大：这种情况是完美的情况，最强壮的牛放在最下面，可能能达到最小的最大压力
因此我们按照w+s从小到大去排列