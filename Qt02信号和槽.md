---
title: Qt02信号和槽
date: 2025-03-13 10:10:16
tags:
- Qt学习
categories:
- Qt
cover: https://bu.dusays.com/2025/03/13/67d2de49d9711.png
---

### <font color="FF0000">一、信号和槽机制分析</font>

​	**信号**（Signal）就是在特定情况下被发射的事件，例如PushButton 最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射的 CurrentIndexChanged() 信号。

​	GUI 程序设计的主要内容就是对界面上各组件的信号的响应，只需要知道什么情况下发射哪些信号，合理地去响应和处理这些信号就可以了。

​	**槽**（Slot）就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。

​	信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：

```c++
QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));
connect(发出信号的对象，发出的信号，接收信号的对象，接收到信号之后需要调用的函数（槽函数））
```

**connect()函数最常用的一般形式：**

```c++
connect(sender, signal(信号）, receiver, slot（槽）);
```

![](https://bu.dusays.com/2025/03/13/67d27c859f78b.png)

```c++
  //创建第一个按钮
    QPushButton *btn=new QPushButton;
    //不能用btn->show();//show是以顶层方式弹出控件
    //让btn在widget窗口显示
    btn->setParent(this);//this指向当前对象的指针（即widget的地址）
    //显示文本
    btn->setText("关闭窗口");

    //用信号和槽去实现点击按钮关闭窗口
    connect(btn,&QPushButton::clicked,this,&QWidget::close);
```

### <font color="FF0000">二、自定义信号槽</font>

1、定义自定义信号

在这个的基础上，我们先设定一个需求：屌丝男发向白富美表白，发送表白信号，白富美接收信号，并回应同意。

这里面有两个对象，一个屌丝男，一个白富美，我们将使用自定义的信号和槽将他们联系起来。

![](https://bu.dusays.com/2025/03/13/67d27ebd77f3f.png)

类名自定义为boy，选择QObject为基类是为了将此类加入qt children中，而 QObject 是最基本的类。以同样的方式创建Girl类。

2、在boy类中加入自定义信号

![](https://bu.dusays.com/2025/03/14/67d3e97f319ca.png)

3、 在Girl类头文件和源文件添加自定义槽函数的定义和实现

![](https://bu.dusays.com/2025/03/14/67d3ea0b48134.png)

![](https://bu.dusays.com/2025/03/14/67d3ea110e236.png)

4、 在widget.h中的widget类中添加两个成员，一个boy对象xgg（小哥哥），girl对象xjj（小姐姐）两个指针。

![](https://bu.dusays.com/2025/03/14/67d3ea460c19f.png)

5、 在widget.cpp中new出对象并添加连接。

![](https://bu.dusays.com/2025/03/07/67cad87144911.png)

6、 运行程序，程序在表白函数中发送示爱信息，接收者收到信息并执行相应的槽函数。

运行结果：打印出了槽函数中的信息。实现了自定义的信号和槽函数

![](https://bu.dusays.com/2025/03/14/67d3ea8da7844.png)

7、 总结：自定义信号和槽的区别，**信号和槽都为void类型**，信号只需要定义，**不需要实现**，而槽函数**既需要定义，也需要实现**，**信号和槽都可以有参数也都可以重载**。emit是出发信号的标志，可要可不要。

### <font color="FF0000">三、自定义信号和槽发生重载如何解决？</font>

自定义的信号和槽**可以带参数**，**可以重载**，但是重载（或者带参数）后如何去用connect关联呢？

首先看需求，高富帅表白成功后，他们就很有默契了。他们就要约会对不会，男的想说我们去看电影吧，女孩就很听男的话，收到信号后，就同意男孩，我们就去看电影，就是男孩说什么，女孩就同意男孩也说什么，这之间的话，就通过信号的参数来传递。

好，还是来到我们上节课的项目。

1、 在boy.h的signals下重载love函数，带一个QString参数，就是这个传过去一句话，女孩也说这句话。

![](https://bu.dusays.com/2025/03/14/67d3eb6b3233b.png)

记住，这个信号只需要定义，不需要实现，只要知道定义了这么一个带一个参数的信号就行了。触发这个信号，还需要一个QString的参数。

2、 在girl.cpp也重载一个带参数的回应的槽函数

![](https://bu.dusays.com/2025/03/14/67d3eafc0227e.png)

![](https://bu.dusays.com/2025/03/14/67d3eb4298513.png)

在实现的函数，将参数输出

3、 回到widget.cpp中会发现原来写好的没问题的connect函数有错误了。

![](https://bu.dusays.com/2025/03/07/67cadb9162646.png)

![](https://bu.dusays.com/2025/03/14/67d3ebb51a45e.png)

编译后发现错误，重载函数有歧义错误。什么意思呢，信号和槽的连接函数中，就是一个函数名，也就是函数地址，有没有发现，我们在重载之后，就有了两个love信号，也有了两个lovetoo槽，那么这个函数指针，到底指的是哪一个呢？这就让编译器为难了。

4、 我们可以使用带参数的函数指针来指向我们所要指向的那个函数，这个就可以消除歧义。

![](https://bu.dusays.com/2025/03/14/67d3ec0d033cf.png)

这样子就消除错误了。可以编译通过，并运行。

5、 但是我发现一个问题，这样能运行，但是就什么输出都没了，为什么呢？因为我已经把前面的连接函数注释了，我们连接的带参数的信号，而我们原来的出发信号的函数是没有带参数的，所以不会出发这个带参数的信号，信号是可以多次出发的，我们在表白的函数中出发一个带参数的信号

![](https://bu.dusays.com/2025/03/14/67d3ec52acb19.png)

再运行

![](https://bu.dusays.com/2025/03/14/67d3ec6b5ced4.png)

这就能看到女孩那边回应的也是同样的一句话。说明信号跑通了。

6、 总结：注意信号重载函数指针指向哪一个函数的问题，对于重载函数的信号连接，要指明到底连接的是哪一个？

### <font color="FF0000">四、信号连接信号</font>

这部分不放代码了，自己尝试着实践。

1. 信号可以连接信号
2. 一个信号可以连接多个槽（点击按钮，触发信号并关闭窗口）
3. 多个信号可以连接同一个槽（比如多个按钮都可以关闭窗口）
4. 自定义槽函数可以写成：
   1. 类的任意成员函数
   2. 静态函数
   3. 全局函数
   4. lambda表达式

**归根究底：连接的原则就是信号和槽的参数必须一一对应！！**

### <font color="FF0000">五、lambad表达式</font>

表达式用于定义并创建匿名的函数对象，以简化编程工作。

```c++
[函数对象参数](操作符重载函数参数)mutable或exception->返回值
{
函数体
}
```

**1️⃣函数对象参数**

[ ]，标识一个 Lambda 的开始，这部分必须存在，不能省略。函数对象参数 是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使 用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量（包括 Lambda 所在类的 this）。函数对象参数有以下形式：（常用的就是= & this a）

- **空**。没有使用任何函数对象参数。
- **=**。函数体内可以使用 Lambda 所在作用范围内所有可见的局部变量（包 括 Lambda 所在类的 this），并且是**值传递方式**（相当于编译器自动为我 们按值传递了所有局部变量）。
- **&**。函数体内可以使用 Lambda 所在作用范围内所有可见的局部变量（包 括 Lambda 所在类的 this），并且是**引用传递方式**（相当于编译器自动为 我们按引用传递了所有局部变量）。
- **this**。函数体内可以使用 Lambda 所在类中的成员变量。
- **a**。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的。要修改传递进来的 a 的拷贝，可以添加 mutable 修饰符。
- **&a**。将 a 按引用进行传递。
- **a, &b**。将 a 按值进行传递，b 按引用进行传递。
- **=，&a, &b**。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。
- **&, a, b**。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。

**如何用lambda表达式去修改按钮的名称：**

```c++
//函数对象参数: =
[=](){
         btn->setText("aaaa");
     }();

//函数对象参数:a
     [btn](){
          btn->setText("aaaa");
   //由于函数对象参数为btn，因此只能对btn操作，引入btn1会报错
          //btn1->setText("bbbb");
      }();
```

<font color="FF0000">**注意：**</font>不加( )只是对lambad表达式的声明，加上( )才是对它的调用。（由于btn在创建的时候lambad作用范围内是不可见的，因此需要用=让lambad表达式认识btn这个局部变量）

**2️⃣操作符重载函数参数**

标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过 按值（如：(a,b)）和按引用（如：(&a,&b)）两种方式进行传递

**3️⃣可修改标示符**

mutable 声明，这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）

**4️⃣错误抛出标示符**

exception 声明，这部分也可以省略。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int）

**5️⃣函数返回值**

-> 返回值类型，标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。

**如**：int一个ret去接收lanbda表达式返回的结果（注意：要用->标识返回值的类型）

```c++
    int ret=[]()->int{return 1000;}();
    qDebug()<<"ret=:"<<ret;　　
```

**6️⃣函数体**

{ }，标识函数的实现，这部分不能省略，但函数体可以为空

**💛💛💛槽函数也可以使用 Lambda 表达式的方式进行处理：**

```c++
   //创建两个按钮
 QPushButton *myBtn = new QPushButton(this);
 QPushButton *myBtn1 = new QPushButton(this);
 //移动第二个按钮
 myBtn1->move(100,100);
 int m =10;
 //用槽函数（lambda表达式）改变m的copy值
 connect(myBtn,&QPushButton::clicked,this,[m]()mutable{m=100 + 10;qDebug() << m;});
 connect(myBtn1,&QPushButton::clicked,this,[=]() {qDebug() << m;});
 qDebug() << m;

}
```

对于第一个connect函数来说：

```c++
connect(myBtn,&QPushButton::clicked,this,[m]()mutable{m=100+10;qDebug()<<m;});
```

当函数对象参数为m时候，若要修改该值传递进来的拷贝，需要加上mutable 关键字。（注意只能修改拷贝，而不是值本身）

**一般来说，lambda表达式中很少去加关键字的，除非你有什么特殊的需求。**

**总的来说：**

- 用lambda写槽函数可以在lambda表达式的函数体内写多个函数。（如上面m=100+10;和qDebug()<<m;)
- lambda常用表达式：

```c++
[=](){}
```

对于嵌套窗口，其坐标是相对于父窗口来说的。
